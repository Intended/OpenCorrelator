/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package datacorrelator;

import java.awt.Desktop;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.Math;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author Intended
 */
public class MainJFrame extends javax.swing.JFrame {

    /**
     * Creates new form MainJFrame
     */
    public MainJFrame() {
        reordered = new twoArrays();
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jText_Explanation = new javax.swing.JTextArea();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList_path = new javax.swing.JList();
        btn_help = new javax.swing.JButton();
        btn_remove = new javax.swing.JButton();
        btn_add = new javax.swing.JButton();
        btn_correlate = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("OpenCorrelator");
        setMaximumSize(new java.awt.Dimension(800, 600));
        setMinimumSize(new java.awt.Dimension(800, 600));
        setName("frm_mainFrame"); // NOI18N

        jLabel1.setFont(new java.awt.Font("Calibri", 1, 24)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("OpenCorrelator");

        jText_Explanation.setColumns(20);
        jText_Explanation.setFont(new java.awt.Font("Calibri", 0, 18)); // NOI18N
        jText_Explanation.setRows(5);
        jText_Explanation.setText("The OpenCorrelator checker makes it easy to check \na large number of datasets for potential correlations. \nTo use it, just add correctly formatted .csv file using \nthe Add button below. To learn how to correctly \nformat the data files press the help button.");
        jText_Explanation.setEditable(false);
        jScrollPane2.setViewportView(jText_Explanation);

        jScrollPane1.setViewportView(jList_path);

        btn_help.setFont(new java.awt.Font("Calibri", 0, 11)); // NOI18N
        btn_help.setText("Help");
        btn_help.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_helpActionPerformed(evt);
            }
        });

        btn_remove.setFont(new java.awt.Font("Calibri", 0, 11)); // NOI18N
        btn_remove.setText("Remove");
        btn_remove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_removeActionPerformed(evt);
            }
        });

        btn_add.setFont(new java.awt.Font("Calibri", 0, 11)); // NOI18N
        btn_add.setText("Add");
        btn_add.setToolTipText("");
        btn_add.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_addActionPerformed(evt);
            }
        });

        btn_correlate.setFont(new java.awt.Font("Calibri", 0, 11)); // NOI18N
        btn_correlate.setText("Correlate");
        btn_correlate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_correlateActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(321, 321, 321)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(198, 198, 198)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 404, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 404, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(198, 198, 198))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(btn_help)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btn_remove)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btn_add)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btn_correlate)
                .addGap(260, 260, 260))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(50, 50, 50)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(47, 47, 47)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(50, 50, 50)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btn_help)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(btn_remove)
                        .addComponent(btn_add)
                        .addComponent(btn_correlate)))
                .addContainerGap(126, Short.MAX_VALUE))
        );

        jLabel1.getAccessibleContext().setAccessibleName("lbl_OpenCorrelator");
        btn_add.getAccessibleContext().setAccessibleName("btn_add");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btn_helpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_helpActionPerformed
        try {
            // TODO add your handling code here:
            // methods are supported using isDesktopSupported()...
            // methods are supported using isDesktopSupported()...
            
            String htmlFilePath = "help.html"; // path to your new file
            File htmlFile = new File(htmlFilePath);

            // open the default web browser for the HTML page
            Desktop.getDesktop().browse(htmlFile.toURI());s
        } catch (IOException ex) {
            Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btn_helpActionPerformed

    private void btn_addActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_addActionPerformed
        // TODO add your handling code here:
        JFileChooser fc = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter("CSV Files Only", "csv");
        fc.setFileFilter(filter);
        
        if(fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
                DefaultListModel dlm = new DefaultListModel();

                for(int i = 0; i < jList_path.getModel().getSize(); i++)
                {
                    dlm.addElement(jList_path.getModel().getElementAt(i));
                }
                
                if(!dlm.contains(fc.getSelectedFile().getAbsolutePath()))
                {
                    dlm.addElement(fc.getSelectedFile().getAbsolutePath());
                    jList_path.setModel(dlm);
                }  
                else
                {
                    JOptionPane.showMessageDialog(this, "File already added.");
                }
        }   
        
    }//GEN-LAST:event_btn_addActionPerformed

    private void btn_correlateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_correlateActionPerformed
        // TODO add your handling code here:
        
        ///
        /// Load files
        ///
        
        int number_of_files = jList_path.getModel().getSize();
        if(number_of_files <= 1)
        {
            JOptionPane.showMessageDialog(this, "Two CSV files must be selected.");
            return;
        }
            
        String[] file_names = new String[number_of_files];
        
        for(int i = 0; i < number_of_files; i++)
            file_names[i] = (String) jList_path.getModel().getElementAt(i);
        
        ArrayList<DataSet> datasets = new ArrayList<>();
        for(int i = 0; i < number_of_files; i++){
            try {
                DataSet.readFile(file_names[i]);
                while(DataSet.sets_remaining_in_file != 0){
                  DataSet.importData(datasets);
                }
            } catch (FileNotFoundException ex) {
                Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        ///
        /// Create Results Array
        ///
        
        Results[] results = new Results[datasets.size()*(datasets.size()-1)/2];
        int n = 0;
        for(int i = 0; i < datasets.size(); i++){
            for(int j = i + 1; j < datasets.size(); j++){
                results[n] = Correlate(datasets.get(i), datasets.get(j));
                n++;
            }
        }
        
        FinishJFrame fjf = new FinishJFrame(results, this);
        this.setVisible(false);
        fjf.setVisible(true);
        
    }//GEN-LAST:event_btn_correlateActionPerformed

    private static Results Correlate(DataSet dataA, DataSet dataB){
        Results result = new Results();
        result.dataset1 = dataA.dataName;
        result.dataset2 = dataB.dataName;
        result.pearson = 0;
        result.spearman = 0;
        result.corr = "failure";
        
        // Create dataset subsets for shared time periods
        int startA = dataA.year.get(0);
        int startB = dataB.year.get(0);
        int endA = dataA.year.get(dataA.year.size()-1);
        int endB = dataB.year.get(dataB.year.size()-1);
        
        int minimumDataPoints = 5;
        
        int start = startA;
        if(startB > startA)
            start = startB;
        int end = endA;
        if(endB < endA)
            end = endB;
        
        result.startyear = start;
        result.endyear = end;
        
        if(end <= start+minimumDataPoints-1)
            return result;
        
        float[] subDataA = new float[end - start + 1];
        float[] subDataB = new float[end - start + 1];
        
        int a = 0;
        for(int i = dataA.year.indexOf(start); i <= dataA.year.indexOf(end); i++){
            subDataA[a] = dataA.data.get(i);
            a++;
        }
        a = 0;
        for(int i = dataB.year.indexOf(start); i <= dataB.year.indexOf(end); i++){
            subDataB[a] = dataB.data.get(i);
            a++;
        }
        // Sub arrays complete
        
        // Calculate Pearson Coefficient
        result.pearson = PearsonCorrelation(subDataA, subDataB);
        result.spearman = SpearmanCorrelation(subDataA, subDataB);
        // Calculate Spearman Coefficient
        
        if(result.pearson > 0.95 || result.spearman > 0.95)
            result.corr = "Very strongly correlated";
        else if (result.pearson > 0.85 || result.spearman > 0.85)
            result.corr = "Strongly correlated";
        else if (result.pearson > 0.7 || result.spearman > 0.7)
            result.corr = "Moderately correlated";
        else if (result.pearson > 0.5 || result.spearman > 0.5)
            result.corr = "Weakly correlated";
        else if (result.pearson < -0.95 || result.spearman < -0.95)
            result.corr = "Very strongly negatively-correlated";
        else if (result.pearson < -0.85 || result.spearman < -0.85)
            result.corr = "Strongly negatively-correlated";
        else if (result.pearson < -0.7 || result.spearman < -0.7)
            result.corr = "Moderately negatively-correlated";
        else if (result.pearson < -0.5 || result.spearman < -0.5)
            result.corr = "Weakly negatively-correlated";
        else
            result.corr = "Not correlated";
        
        return result;
    }
    
    /**
    * PearsonCorrelation takes two arrays of floats and returns the Pearson
    * correlation of the two datasets.
    */
    private static float PearsonCorrelation(float[] dataA, float[] dataB){
      float pearson = Covariance(dataA,dataB)/(Sigma(dataA)*Sigma(dataB));
      return pearson;
    }
    
    /**
    * Covariance takes two arrays of floats and returns the covariance of the two
    * datasets.
    */
    private static float Covariance(float[] dataA, float[] dataB){
      float avgA = Average(dataA);
      float avgB = Average(dataB);
      float var = 0;
      for(int i = 0; i < dataA.length; i++){
        var += (dataA[i]-avgA)*(dataB[i]-avgB);
      }
      return var;
    }
    
    /**
    * Sigma takes an array of floats and returns the standard deviation of the
    * values.
    */
    private static float Sigma(float[] data){
      float average = Average(data);
      float var = 0;
      for(float datapoint: data){
        var += (datapoint-average)*(datapoint-average);
      }
      float sigma = (float) Math.sqrt(var);
      return sigma;
    }
    
    /**
    * Average takes an array of floats and returns the mean value.
    */
    private static float Average(float[] data){
      float average = 0;
      for(float datapoint: data){
        average += datapoint;
      }
      average /= data.length;
      return average;
    }
    
    private class twoArrays{
        public ArrayList<Float> dataA;
        public ArrayList<Float> dataB;
        public twoArrays(){
            this.dataA = new ArrayList<>();
            this.dataB = new ArrayList<>();
        }
    }
    
    /**
    * SpearmanCorrelation is called to calculate the spearman correlation
    * coefficient of two datasets.
    */
    private static float SpearmanCorrelation(float[] dataA, float[] dataB){
      twoArrays reordered = Reorder(dataA, dataB);
      float[] tA = new float[reordered.dataA.size()];
      float[] tB = new float[reordered.dataB.size()];
      for(int i = 0; i < tA.length; i++){
          Float f = reordered.dataA.get(i);
          tA[i] = (f != null ? f : Float.NaN);
      }
      for(int i = 0; i < tB.length; i++){
          Float f = reordered.dataB.get(i);
          tB[i] = (f != null ? f : Float.NaN);
      }
      float[] rdA = Rank(tA);
      float[] rdB = Rank(tB);
      float spearman = PearsonCorrelation(rdA,rdB);
      return spearman;
    }
    
  /**
    * Rank is called to convert the dataset values into rankings.
    */
    public static float[] Rank(float[] data){
      float[] ranked = data;
      for(float dp1: ranked){
        float current = 0;
        int above = 0;
        int equals = 0;
        int below = 0;
        for(float dp2: data){
          if(dp2 < dp1)
            below++;
          else if(dp2 == dp1)
            equals++;
          else
            above++;
        }
        dp1 = (float) ((1 + below) + 0.5*equals*(equals - 1)/equals);
      }
      return ranked;
    }
    
      /**
        * Reorder is called to reorder the datasets by ascending dataA values.
        */ 
      private static twoArrays reordered;
      private static twoArrays Reorder(float[] dataA, float[] dataB){
        if(reordered.dataA == null)
            System.out.print("niggers");
        reordered.dataA.clear();
        reordered.dataB.clear();
        int var = 0;
        for(int i = 0; i < dataA.length; i++){
          var = MinimumLocation(dataA,i);
          reordered.dataA.add(dataA[var]);
          reordered.dataB.add(dataB[var]);
        }
        return reordered;
      }
    
    /**
      * MinimumLocation is called by the reorder method. Used to determine which
      * element should be moved next.
      */
    public static int MinimumLocation(float[] data, int startpos){
      float lowest = data[startpos];
      for(int i = startpos; i < data.length; i++){
        if(data[i]<=lowest){
          startpos = i;
          lowest = data[i];
        }
      }
      return startpos;
    }
      
    private void btn_removeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_removeActionPerformed
        // TODO add your handling code here:
        DefaultListModel dlm = new DefaultListModel();
        
        for(int i=0; i < jList_path.getModel().getSize(); i++)
        {
            dlm.addElement(jList_path.getModel().getElementAt(i));
        }
        
        dlm.removeElement(jList_path.getSelectedValue());
        
        jList_path.setModel(dlm);
    }//GEN-LAST:event_btn_removeActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainJFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btn_add;
    private javax.swing.JButton btn_correlate;
    private javax.swing.JButton btn_help;
    private javax.swing.JButton btn_remove;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JList jList_path;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jText_Explanation;
    // End of variables declaration//GEN-END:variables

    
}
